---
title: 'Assignment #9'
author: "Elliot Smith"
date: "10/28/2018"
output: pdf_document
---

```{r, echo = FALSE}

########## Workspace Prep ##########



## Load in the necessary packages

library(ggplot2)
library(truncdist)
library(coda)
library(tidyr)
library(knitr)

## No scientific notation

options(scipen = 999)

```

# Problem 1

## Part i

## Part ii

## Part iii

## Part iv

## Part v

# Problem 2

```{r, echo = FALSE}

########## Problem 2 ##########



## Input the known data and parameters

y_j <- c(28, 8, -3, 7, -1, 1, 18, 12)
sigma_j <- c(15, 10, 16, 11, 9, 11, 10, 18)
sigma_j_sq <- sigma_j^2
names(y_j) <- c("A", "B", "C", "D", "E","F", "G", "H")
names(sigma_j) <- c("A", "B", "C", "D", "E","F", "G", "H")

J <- length(y_j)

```

$[\bar{y}_{\cdot{j}}|\theta_j, \sigma_j] \stackrel{indep}{\sim} N(\theta_j, \sigma^2_j), \qquad j = 1, ..., J$
\newline
$[\theta_j|\mu, \sigma_{\theta}] \stackrel{iid}{\sim} N(\mu, \sigma^2_{\theta}), \qquad j = 1, ..., J$
\newline
$p(\mu, \theta) = p(\mu)p(\theta), \qquad p(\mu) \propto 1, \qquad [\sigma_\theta] \sim Uniform(0, A), \qquad A = 100$

## Part i - BDA Exercise 5.3

### Part a

According to Formula 5.21 on BDA page 117, we have the following form for $p(\tau|y)$:
\newline
$p(\tau|y) \propto p(\tau) V^{-1/2}_\mu \prod_{j=1}^J(\sigma^2_j + \tau^2)^{-1/2}exp\bigg(-\frac{(\bar{y}_{{\cdot}j} - \hat{\mu})^2}{2(\sigma^2_j + \tau^2)}\bigg)$
\newline
\newline
\newline
The following will allow us to subsitute into the equation, from Formula 5.20 on BDA page 117:
\newline
$\hat{\mu} = \frac{\sum_{j=1}^J \frac{1}{\sigma^2_j + \tau^2} \bar{y}_{{\cdot}j}}{\sum_{j=1}^J \frac{1}{\sigma^2_j + \tau^2}}$
\newline
$V_\mu^{-1} = \sum_{j=1}^J\frac{1}{\sigma^2_j + \tau^2}$

```{r, echo = FALSE}

##### Part i #####



### A = 100 ###



## Set some intial values

theta_j <- y_j
mu <- mean(theta_j)
sigma_theta <- sd(y_j)

A <- 100
S <- 10000

## Create the containers for the posterior draws

post_theta_j <- array(0, c(S, J))
post_mu <- numeric(S)
post_sig_theta <- numeric(S)
post_kappa_j <- array(0, c(S,J))

## Run the MCMC

for(s in 1:S) {
    
    ## Sample from mu
    
    Q_mu <- sum(1/(sigma_j^2 + sigma_theta^2))
    ell_mu <- sum(y_j/(sigma_j^2 + sigma_theta^2))
    mu <- rnorm(n = 1,
                mean = Q_mu^-1*ell_mu,
                sd = sqrt(Q_mu^-1))
    
    ## Sample from theta_j
    
    Q_theta <- 1/sigma_j^2 + 1/sigma_theta^2
    ell_theta <- y_j/sigma_j^2 + mu/sigma_theta^2
    theta_j <- rnorm(n = J,
                     mean = Q_theta^-1*ell_theta,
                     sd = sqrt(Q_theta^-1))
    
    ## Sample from sigma_theta
    
    eta_theta <- rtrunc(n = 1, 
                        'gamma',
                        a = 1/A^2,
                        b = A, 
                        shape = J/2 - 1/2,
                        rate =  sum((theta_j-mu)^2)/2)
    sigma_theta <- 1/sqrt(eta_theta)
    
    post_mu[s] <- mu
    post_theta_j[s,] <- theta_j
    post_sig_theta[s] <- sigma_theta
    
    # Get the shrinkage parameter
    
    post_kappa_j[s,] <- sigma_j^2/(sigma_theta^2 + sigma_j^2)
    
}

## Function for V inverse

v_inv <- function(sigma_j_sq, sigma_theta) {
    
    sum(1 / (sigma_j_sq + sigma_theta^2))
    
}

## Function for mu hat

mu_hat <- function(y_j, sigma_j_sq, sigma_theta) {
    
    sum(1 / (sigma_j_sq + sigma_theta^2) * y_j) / v_inv(sigma_j_sq, sigma_theta)
    
}

## Function for post sigma_theta

post_sigma_theta <- function(y_j, sigma_j_sq, sigma_theta, mu_h) {
    
    v_inv(sigma_j_sq, sigma_theta)^(-(1 / 2)) * prod((sigma_j_sq + sigma_theta^2)^(-(1 / 2) * exp(-(y_j - mu_h)^2 / (2 * sigma_j_sq + sigma_theta^2))))
    
}

## Set a sequence for sigma_theta

seq_sigma_theta <- seq(from = 0, to = 30, length.out = S)

## Set a container for plotting the posterior of sigma_theta

post_sigma_theta_plot <- numeric()

## Loop to sample from post sigma_theta and plot the results

for (i in 1:length(seq_sigma_theta)) {
    
    mu_h <- mu_hat(y_j, sigma_j_sq, seq_sigma_theta[i])
    post_sigma_theta_plot[i] <- post_sigma_theta(y_j, sigma_j_sq, seq_sigma_theta[i], mu_h)
    
}

plot(x = seq_sigma_theta, y = post_sigma_theta_plot, type = 'l',
     xlab = 'sigma_theta', ylab = 'p(sigma_theta|y)', main = 'Marginal Posterior Density')

```

```{r, echo = FALSE}

## Plot the posterior draws of sigma_theta

hist(post_sig_theta)

```

```{r, echo = FALSE}

## Plot the posterior draws of mu

labels = c("A", "B", "C", "D", "E", "F", "G", "H")

ggplot(gather(data.frame(post_theta_j)), aes(value, linetype=key)) + geom_freqpoly(binwidth=2) + 
    scale_linetype_discrete(name = "School", labels = labels)

```

```{r, echo = FALSE}

par(mfrow = c(2, 4))

for (col in 1:ncol(post_theta_j)) {
    
    hist(post_theta_j[,col], main = paste("Hist of School" , labels[col]))
    
}

par(mfrow = c(1, 1))

```

```{r, echo = FALSE}

## Calculate the probability table

max_vals <- apply(post_theta_j, 1, which.max)
prob_max <- table(max_vals) / S

prob_table <- matrix(NA, J, J)

for (i in 1:(J-1)) {
    
    for (j in (i+1):J) {
        
        prob_table[i,j] = sum(post_theta_j[,i] > post_theta_j[,j]) / S
        prob_table[j,i] = 1 - prob_table[i,j]
        
    }
    
}

prob_table[is.na(prob_table)] = "---"
schools = c("A", "B", "C", "D", "E", "F", "G", "H")
colnames(prob_table) <- schools
kable(cbind(schools, prob_max, prob_table))

```

### Part b

```{r, echo = FALSE}

### sigma_theta = Infinity ###



## Set some intial values

theta_j <- y_j
mu <- mean(theta_j)
sigma_theta <- sd(y_j)

S <- 10000

## Create the containers for the posterior draws

post_theta_j <- array(0, c(S, J))
post_mu <- numeric(S)
post_sig_theta <- numeric(S)
post_kappa_j <- array(0, c(S,J))

## Run the MCMC

for(s in 1:S) {
    
    ## Sample from mu
    
    Q_mu <- sum(1/(sigma_j^2 + sigma_theta^2))
    ell_mu <- sum(y_j/(sigma_j^2 + sigma_theta^2))
    mu <- rnorm(n = 1,
                mean = Q_mu^-1*ell_mu,
                sd = sqrt(Q_mu^-1))
    
    ## Sample from theta_j
    
    Q_theta <- 1/sigma_j^2 + 1/sigma_theta^2
    ell_theta <- y_j/sigma_j^2 + mu/sigma_theta^2
    theta_j <- rnorm(n = J,
                     mean = Q_theta^-1*ell_theta,
                     sd = sqrt(Q_theta^-1))
    
    ## Sample from sigma_theta
    
    # eta_theta <- rtrunc(n = 1, 
    #                     'gamma',
    #                     a = 1/A^2,
    #                     b = A, 
    #                     shape = J/2 - 1/2,
    #                     rate =  sum((theta_j-mu)^2)/2)
    # sigma_theta <- 1/sqrt(eta_theta)
    
    sigma_theta <- 99999
    
    post_mu[s] <- mu
    post_theta_j[s,] <- theta_j
    post_sig_theta[s] <- sigma_theta
    
    # Get the shrinkage parameter
    
    post_kappa_j[s,] <- sigma_j^2/(sigma_theta^2 + sigma_j^2)
    
}

## Function for V inverse

v_inv <- function(sigma_j_sq, sigma_theta) {
    
    sum(1 / (sigma_j_sq + sigma_theta^2))
    
}

## Function for mu hat

mu_hat <- function(y_j, sigma_j_sq, sigma_theta) {
    
    sum(1 / (sigma_j_sq + sigma_theta^2) * y_j) / v_inv(sigma_j_sq, sigma_theta)
    
}

## Function for post sigma_theta

post_sigma_theta <- function(y_j, sigma_j_sq, sigma_theta, mu_h) {
    
    v_inv(sigma_j_sq, sigma_theta)^(-(1 / 2)) * prod((sigma_j_sq + sigma_theta^2)^(-(1 / 2) * exp(-(y_j - mu_h)^2 / (2 * sigma_j_sq + sigma_theta^2))))
    
}

```

```{r, echo = FALSE}

## Plot the posterior draws of mu

labels = c("A", "B", "C", "D", "E", "F", "G", "H")

ggplot(gather(data.frame(post_theta_j)), aes(value, linetype=key)) + geom_freqpoly(binwidth=2) + 
    scale_linetype_discrete(name = "School", labels = labels)

```

```{r, echo = FALSE}

par(mfrow = c(2, 4))

for (col in 1:ncol(post_theta_j)) {
    
    hist(post_theta_j[,col], main = paste("Hist of School" , labels[col]))
    
}

par(mfrow = c(1, 1))

```

```{r, echo = FALSE}

## Calculate the probability table

max_vals <- apply(post_theta_j, 1, which.max)
prob_max <- table(max_vals) / S

prob_table <- matrix(NA, J, J)

for (i in 1:(J-1)) {
    
    for (j in (i+1):J) {
        
        prob_table[i,j] = sum(post_theta_j[,i] > post_theta_j[,j]) / S
        prob_table[j,i] = 1 - prob_table[i,j]
        
    }
    
}

prob_table[is.na(prob_table)] = "---"
schools = c("A", "B", "C", "D", "E", "F", "G", "H")
colnames(prob_table) <- schools
kable(cbind(schools, prob_max, prob_table))

```

### Part c

BLAH BLAH

### Part d

BLAH BLAH

## Part ii

## Part iii

# Code Appendix